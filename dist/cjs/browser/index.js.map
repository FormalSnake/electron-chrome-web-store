{
  "version": 3,
  "sources": ["../../../src/browser/index.ts", "../../../src/browser/api.ts", "../../../src/browser/utils.ts", "../../../src/common/constants.ts", "../../../src/browser/installer.ts", "../../../node_modules/pbf/index.js", "../../../src/browser/crx3.ts", "../../../src/browser/id.ts", "../../../src/browser/loader.ts", "../../../src/browser/updater.ts"],
  "sourcesContent": ["import { app, session as electronSession } from 'electron'\nimport * as path from 'node:path'\nimport { existsSync } from 'node:fs'\nimport { createRequire } from 'node:module'\n\nimport { registerWebStoreApi } from './api'\nimport { loadAllExtensions } from './loader'\nexport { loadAllExtensions } from './loader'\nexport { installExtension, uninstallExtension, downloadExtension } from './installer'\nimport { initUpdater } from './updater'\nexport { updateExtensions } from './updater'\nimport { getDefaultExtensionsPath } from './utils'\nimport {\n  AfterInstall,\n  AfterUninstall,\n  BeforeInstall,\n  CustomSetExtensionEnabled,\n  ExtensionId,\n  OverrideExtensionInstallStatus,\n  WebStoreState\n} from './types'\n\nfunction resolvePreloadPath(modulePath?: string) {\n  // Attempt to resolve preload path from module exports\n  try {\n    return createRequire(__dirname).resolve('electron-chrome-web-store/preload')\n  } catch (error) {\n    if (process.env.NODE_ENV !== 'production') {\n      console.error(error)\n    }\n  }\n\n  const preloadFilename = 'chrome-web-store.preload.js'\n\n  // Deprecated: use modulePath if provided\n  if (modulePath) {\n    process.emitWarning(\n      'electron-chrome-web-store: \"modulePath\" is deprecated and will be removed in future versions.',\n      { type: 'DeprecationWarning' }\n    )\n    return path.join(modulePath, 'dist', preloadFilename)\n  }\n\n  // Fallback to preload relative to entrypoint directory\n  return path.join(__dirname, preloadFilename)\n}\n\ninterface ElectronChromeWebStoreOptions {\n  /**\n   * Session to enable the Chrome Web Store in.\n   * Defaults to session.defaultSession\n   */\n  session?: Electron.Session\n\n  /**\n   * Path to the 'electron-chrome-web-store' module.\n   *\n   * @deprecated See \"Packaging the preload script\" in the readme.\n   */\n  modulePath?: string\n\n  /**\n   * Path to extensions directory.\n   * Defaults to 'Extensions/' under app's userData path.\n   */\n  extensionsPath?: string\n\n  /**\n   * Load extensions installed by Chrome Web Store.\n   * Defaults to true.\n   */\n  loadExtensions?: boolean\n\n  /**\n   * Whether to allow loading unpacked extensions. Only loads if\n   * `loadExtensions` is also enabled.\n   * Defaults to false.\n   */\n  allowUnpackedExtensions?: boolean\n\n  /**\n   * List of allowed extension IDs to install.\n   */\n  allowlist?: ExtensionId[]\n\n  /**\n   * List of denied extension IDs to install.\n   */\n  denylist?: ExtensionId[]\n\n  /**\n   * Whether extensions should auto-update.\n   */\n  autoUpdate?: boolean\n\n  /**\n   * Minimum supported version of Chrome extensions.\n   * Defaults to 3.\n   */\n  minimumManifestVersion?: number\n\n  /**\n   * Called prior to installing an extension. If implemented, return a Promise\n   * which resolves with `{ action: 'allow' | 'deny' }` depending on the action\n   * to be taken.\n   */\n  beforeInstall?: BeforeInstall\n\n  /**\n   * Called after an extension is successfully installed.\n   */\n  afterInstall?: AfterInstall\n\n  /**\n   * Called after an extension is uninstalled.\n   */\n  afterUninstall?: AfterUninstall\n\n  /**\n   * Custom handler for enabling/disabling extensions.\n   * Return true if the operation was successful.\n   */\n  customSetExtensionEnabled?: CustomSetExtensionEnabled\n\n  /**\n   * Override the extension install status check.\n   * Return a custom status string or undefined to use the default behavior.\n   */\n  overrideExtensionInstallStatus?: OverrideExtensionInstallStatus\n}\n\n/**\n * Install Chrome Web Store support.\n *\n * @param options Chrome Web Store configuration options.\n */\nexport async function installChromeWebStore(opts: ElectronChromeWebStoreOptions = {}) {\n  const session = opts.session || electronSession.defaultSession\n  const extensionsPath = opts.extensionsPath || getDefaultExtensionsPath()\n  const loadExtensions = typeof opts.loadExtensions === 'boolean' ? opts.loadExtensions : true\n  const allowUnpackedExtensions =\n    typeof opts.allowUnpackedExtensions === 'boolean' ? opts.allowUnpackedExtensions : false\n  const autoUpdate = typeof opts.autoUpdate === 'boolean' ? opts.autoUpdate : true\n  const minimumManifestVersion =\n    typeof opts.minimumManifestVersion === 'number' ? opts.minimumManifestVersion : 3\n  const beforeInstall = typeof opts.beforeInstall === 'function' ? opts.beforeInstall : undefined\n  const afterInstall = typeof opts.afterInstall === 'function' ? opts.afterInstall : undefined\n  const afterUninstall = typeof opts.afterUninstall === 'function' ? opts.afterUninstall : undefined\n  const customSetExtensionEnabled =\n    typeof opts.customSetExtensionEnabled === 'function'\n      ? opts.customSetExtensionEnabled\n      : undefined\n  const overrideExtensionInstallStatus =\n    typeof opts.overrideExtensionInstallStatus === 'function'\n      ? opts.overrideExtensionInstallStatus\n      : undefined\n\n  const webStoreState: WebStoreState = {\n    session,\n    extensionsPath,\n    installing: new Set(),\n    allowlist: opts.allowlist ? new Set(opts.allowlist) : undefined,\n    denylist: opts.denylist ? new Set(opts.denylist) : undefined,\n    minimumManifestVersion,\n    beforeInstall,\n    afterInstall,\n    afterUninstall,\n    customSetExtensionEnabled,\n    overrideExtensionInstallStatus\n  }\n\n  // Add preload script to session\n  const preloadPath = resolvePreloadPath(opts.modulePath)\n\n  if ('registerPreloadScript' in session) {\n    session.registerPreloadScript({\n      id: 'electron-chrome-web-store',\n      type: 'frame',\n      filePath: preloadPath\n    })\n  } else {\n    // @ts-expect-error Deprecated electron@<35\n    session.setPreloads([...session.getPreloads(), preloadPath])\n  }\n\n  if (!existsSync(preloadPath)) {\n    console.error(\n      new Error(\n        `electron-chrome-web-store: Preload file not found at \"${preloadPath}\". ` +\n          'See \"Packaging the preload script\" in the readme.'\n      )\n    )\n  }\n\n  registerWebStoreApi(webStoreState)\n\n  await app.whenReady()\n\n  if (loadExtensions) {\n    await loadAllExtensions(session, extensionsPath, { allowUnpacked: allowUnpackedExtensions })\n  }\n\n  if (autoUpdate) {\n    void initUpdater(webStoreState)\n  }\n}\n", "import * as fs from 'node:fs'\nimport * as path from 'node:path'\nimport debug from 'debug'\nimport { app, BrowserWindow, ipcMain, nativeImage, NativeImage, Session } from 'electron'\nimport { fetch } from './utils'\n\nimport {\n  ExtensionInstallStatus,\n  MV2DeprecationStatus,\n  Result,\n  WebGlStatus\n} from '../common/constants'\nimport { installExtension, uninstallExtension } from './installer'\nimport { ExtensionId, WebStoreState } from './types'\n\nconst d = debug('electron-chrome-web-store:api')\n\nconst WEBSTORE_URL = 'https://chromewebstore.google.com'\n\nfunction getExtensionInfo(ext: Electron.Extension) {\n  const manifest: chrome.runtime.Manifest = ext.manifest\n  return {\n    description: manifest.description || '',\n    enabled: !manifest.disabled,\n    homepageUrl: manifest.homepage_url || '',\n    hostPermissions: manifest.host_permissions || [],\n    icons: Object.entries(manifest?.icons || {}).map(([size, url]) => ({\n      size: parseInt(size),\n      url: `chrome://extension-icon/${ext.id}/${size}/0`\n    })),\n    id: ext.id,\n    installType: 'normal',\n    isApp: !!manifest.app,\n    mayDisable: true,\n    name: manifest.name,\n    offlineEnabled: !!manifest.offline_enabled,\n    optionsUrl: manifest.options_page\n      ? `chrome-extension://${ext.id}/${manifest.options_page}`\n      : '',\n    permissions: manifest.permissions || [],\n    shortName: manifest.short_name || manifest.name,\n    type: manifest.app ? 'app' : 'extension',\n    updateUrl: manifest.update_url || '',\n    version: manifest.version\n  }\n}\n\nfunction getExtensionInstallStatus(\n  state: WebStoreState,\n  extensionId: ExtensionId,\n  manifest?: chrome.runtime.Manifest\n) {\n  // Allow custom override of install status\n  if (state.overrideExtensionInstallStatus) {\n    const customStatus = state.overrideExtensionInstallStatus(state, extensionId, manifest)\n    if (customStatus !== undefined) {\n      return customStatus\n    }\n  }\n\n  if (manifest && manifest.manifest_version < state.minimumManifestVersion) {\n    return ExtensionInstallStatus.DEPRECATED_MANIFEST_VERSION\n  }\n\n  if (state.denylist?.has(extensionId)) {\n    return ExtensionInstallStatus.BLOCKED_BY_POLICY\n  }\n\n  if (state.allowlist && !state.allowlist.has(extensionId)) {\n    return ExtensionInstallStatus.BLOCKED_BY_POLICY\n  }\n\n  const sessionExtensions = state.session.extensions || state.session\n  const extensions = sessionExtensions.getAllExtensions()\n  const extension = extensions.find((ext) => ext.id === extensionId)\n\n  if (!extension) {\n    return ExtensionInstallStatus.INSTALLABLE\n  }\n\n  if (extension.manifest.disabled) {\n    return ExtensionInstallStatus.DISABLED\n  }\n\n  return ExtensionInstallStatus.ENABLED\n}\n\ninterface InstallDetails {\n  id: string\n  manifest: string\n  localizedName: string\n  esbAllowlist: boolean\n  iconUrl: string\n}\n\nasync function beginInstall(\n  { sender, senderFrame }: Electron.IpcMainInvokeEvent,\n  state: WebStoreState,\n  details: InstallDetails\n) {\n  const extensionId = details.id\n\n  try {\n    if (state.installing.has(extensionId)) {\n      return { result: Result.INSTALL_IN_PROGRESS }\n    }\n\n    let manifest: chrome.runtime.Manifest\n    try {\n      manifest = JSON.parse(details.manifest)\n    } catch {\n      return { result: Result.MANIFEST_ERROR }\n    }\n\n    const installStatus = getExtensionInstallStatus(state, extensionId, manifest)\n    switch (installStatus) {\n      case ExtensionInstallStatus.INSTALLABLE:\n        break // good to go\n      case ExtensionInstallStatus.BLOCKED_BY_POLICY:\n        return { result: Result.BLOCKED_BY_POLICY }\n      default: {\n        d('unable to install extension %s with status \"%s\"', extensionId, installStatus)\n        return { result: Result.UNKNOWN_ERROR }\n      }\n    }\n\n    let iconUrl: URL\n    try {\n      iconUrl = new URL(details.iconUrl)\n    } catch {\n      return { result: Result.INVALID_ICON_URL }\n    }\n\n    let icon: NativeImage\n    try {\n      const response = await fetch(iconUrl.href)\n      const imageBuffer = Buffer.from(await response.arrayBuffer())\n      icon = nativeImage.createFromBuffer(imageBuffer)\n    } catch {\n      return { result: Result.ICON_ERROR }\n    }\n\n    const browserWindow = BrowserWindow.fromWebContents(sender)\n    if (!senderFrame || senderFrame.isDestroyed()) {\n      return { result: Result.UNKNOWN_ERROR }\n    }\n\n    if (state.beforeInstall) {\n      const result: unknown = await state.beforeInstall({\n        id: extensionId,\n        localizedName: details.localizedName,\n        manifest,\n        icon,\n        frame: senderFrame,\n        browserWindow: browserWindow || undefined\n      })\n\n      if (typeof result !== 'object' || typeof (result as any).action !== 'string') {\n        return { result: Result.UNKNOWN_ERROR }\n      } else if ((result as any).action !== 'allow') {\n        return { result: Result.USER_CANCELLED }\n      }\n    }\n\n    state.installing.add(extensionId)\n    await installExtension(extensionId, state)\n    return { result: Result.SUCCESS }\n  } catch (error) {\n    console.error('Extension installation failed:', error)\n    return {\n      result: Result.INSTALL_ERROR,\n      message: error instanceof Error ? error.message : String(error)\n    }\n  } finally {\n    state.installing.delete(extensionId)\n  }\n}\n\ntype IPCChannelHandler = (event: Electron.IpcMainInvokeEvent, ...args: any[]) => any\nconst handledIpcChannels = new Map<string, Map<Session, IPCChannelHandler>>()\n\nexport function registerWebStoreApi(webStoreState: WebStoreState) {\n  /** Handle IPCs from the Chrome Web Store. */\n  const handle = (\n    channel: string,\n    handle: (event: Electron.IpcMainInvokeEvent, ...args: any[]) => any\n  ) => {\n    let handlersMap = handledIpcChannels.get(channel)\n\n    // Handle each channel only once\n    if (!handlersMap) {\n      handlersMap = new Map<Session, IPCChannelHandler>()\n      handledIpcChannels.set(channel, handlersMap)\n\n      ipcMain.handle(channel, async function handleWebStoreIpc(event, ...args) {\n        d('received %s', channel)\n\n        const senderOrigin = event.senderFrame?.origin\n        if (!senderOrigin || !senderOrigin.startsWith(WEBSTORE_URL)) {\n          d('ignoring webstore request from %s', senderOrigin)\n          return\n        }\n\n        const session = event.sender.session\n\n        const handler = handlersMap?.get(session)\n        if (!handler) {\n          d('no handler for session %s', session.storagePath)\n          return\n        }\n\n        const result = await handler(event, ...args)\n        d('%s result', channel, result)\n        return result\n      })\n    }\n\n    // Add handler\n    handlersMap.set(webStoreState.session, handle)\n  }\n\n  handle('chromeWebstore.beginInstall', async (event, details: InstallDetails) => {\n    const { senderFrame } = event\n\n    d('beginInstall', details)\n\n    const result = await beginInstall(event, webStoreState, details)\n\n    if (result.result === Result.SUCCESS) {\n      queueMicrotask(() => {\n        const sessionExtensions = webStoreState.session.extensions || webStoreState.session\n        const ext = sessionExtensions.getExtension(details.id)\n        if (ext && senderFrame && !senderFrame.isDestroyed()) {\n          try {\n            senderFrame.send('chrome.management.onInstalled', getExtensionInfo(ext))\n          } catch (error) {\n            console.error(error)\n          }\n        }\n\n        // Call afterInstall callback if provided\n        if (webStoreState.afterInstall && ext) {\n          try {\n            webStoreState.afterInstall({ id: details.id, manifest: ext.manifest })\n          } catch (error) {\n            console.error('afterInstall callback error:', error)\n          }\n        }\n      })\n    }\n\n    return result\n  })\n\n  handle('chromeWebstore.completeInstall', async (event, id) => {\n    // TODO: Implement completion of extension installation\n    return Result.SUCCESS\n  })\n\n  handle('chromeWebstore.enableAppLauncher', async (event, enable) => {\n    // TODO: Implement app launcher enable/disable\n    return true\n  })\n\n  handle('chromeWebstore.getBrowserLogin', async () => {\n    // TODO: Implement getting browser login\n    return ''\n  })\n  handle('chromeWebstore.getExtensionStatus', async (_event, id, manifestJson) => {\n    const manifest = JSON.parse(manifestJson)\n    return getExtensionInstallStatus(webStoreState, id, manifest)\n  })\n\n  handle('chromeWebstore.getFullChromeVersion', async () => {\n    return {\n      version_number: process.versions.chrome,\n      app_name: app.getName()\n    }\n  })\n\n  handle('chromeWebstore.getIsLauncherEnabled', async () => {\n    // TODO: Implement checking if launcher is enabled\n    return true\n  })\n\n  handle('chromeWebstore.getMV2DeprecationStatus', async () => {\n    return webStoreState.minimumManifestVersion > 2\n      ? MV2DeprecationStatus.SOFT_DISABLE\n      : MV2DeprecationStatus.INACTIVE\n  })\n\n  handle('chromeWebstore.getReferrerChain', async () => {\n    // TODO: Implement getting referrer chain\n    return 'EgIIAA=='\n  })\n\n  handle('chromeWebstore.getStoreLogin', async () => {\n    // TODO: Implement getting store login\n    return ''\n  })\n\n  handle('chromeWebstore.getWebGLStatus', async () => {\n    await app.getGPUInfo('basic')\n    const features = app.getGPUFeatureStatus()\n    return features.webgl.startsWith('enabled')\n      ? WebGlStatus.WEBGL_ALLOWED\n      : WebGlStatus.WEBGL_BLOCKED\n  })\n\n  handle('chromeWebstore.install', async (event, id, silentInstall) => {\n    // TODO: Implement extension installation\n    return Result.SUCCESS\n  })\n\n  handle('chromeWebstore.isInIncognitoMode', async () => {\n    // TODO: Implement incognito mode check\n    return false\n  })\n\n  handle('chromeWebstore.isPendingCustodianApproval', async (event, id) => {\n    // TODO: Implement custodian approval check\n    return false\n  })\n\n  handle('chromeWebstore.setStoreLogin', async (event, login) => {\n    // TODO: Implement setting store login\n    return true\n  })\n\n  handle('chrome.runtime.getManifest', async () => {\n    // TODO: Implement getting extension manifest\n    return {}\n  })\n\n  handle('chrome.management.getAll', async (event) => {\n    const sessionExtensions = webStoreState.session.extensions || webStoreState.session\n    const extensions = sessionExtensions.getAllExtensions()\n    return extensions.map(getExtensionInfo)\n  })\n\n  handle('chrome.management.setEnabled', async (event, id, enabled) => {\n    // Use custom handler if provided\n    if (webStoreState.customSetExtensionEnabled) {\n      try {\n        return await webStoreState.customSetExtensionEnabled(webStoreState, id, enabled)\n      } catch (error) {\n        console.error('customSetExtensionEnabled error:', error)\n        return false\n      }\n    }\n    // TODO: Implement default enabling/disabling extension\n    return true\n  })\n\n  handle(\n    'chrome.management.uninstall',\n    async (event, id, options: { showConfirmDialog: boolean }) => {\n      if (options?.showConfirmDialog) {\n        // TODO: confirmation dialog\n      }\n\n      // Get extension info before uninstalling for afterUninstall callback\n      const sessionExtensions = webStoreState.session.extensions || webStoreState.session\n      const extension = sessionExtensions.getExtension(id) || undefined\n      const manifest: chrome.runtime.Manifest | undefined = extension?.manifest\n\n      try {\n        await uninstallExtension(id, webStoreState)\n        queueMicrotask(() => {\n          event.sender.send('chrome.management.onUninstalled', id)\n\n          // Call afterUninstall callback if provided\n          if (webStoreState.afterUninstall) {\n            try {\n              webStoreState.afterUninstall({ id, extension, manifest })\n            } catch (error) {\n              console.error('afterUninstall callback error:', error)\n            }\n          }\n        })\n        return Result.SUCCESS\n      } catch (error) {\n        console.error(error)\n        return Result.UNKNOWN_ERROR\n      }\n    }\n  )\n}\n", "import * as path from 'node:path'\nimport { app, net } from 'electron'\n\n// Include fallbacks for node environments that aren't Electron\nexport const fetch =\n  // Prefer Node's fetch until net.fetch crash is fixed\n  // https://github.com/electron/electron/pull/45050\n  globalThis.fetch ||\n  net?.fetch ||\n  (() => {\n    throw new Error(\n      'electron-chrome-web-store: Missing fetch API. Please upgrade Electron or Node.'\n    )\n  })\nexport const getChromeVersion = () => process.versions.chrome || '131.0.6778.109'\n\nexport function compareVersions(version1: string, version2: string) {\n  const v1 = version1.split('.').map(Number)\n  const v2 = version2.split('.').map(Number)\n\n  for (let i = 0; i < 3; i++) {\n    if (v1[i] > v2[i]) return 1\n    if (v1[i] < v2[i]) return -1\n  }\n  return 0\n}\n\nexport const getDefaultExtensionsPath = () => path.join(app.getPath('userData'), 'Extensions')\n", "export const ExtensionInstallStatus = {\n  BLACKLISTED: 'blacklisted',\n  BLOCKED_BY_POLICY: 'blocked_by_policy',\n  CAN_REQUEST: 'can_request',\n  CORRUPTED: 'corrupted',\n  CUSTODIAN_APPROVAL_REQUIRED: 'custodian_approval_required',\n  CUSTODIAN_APPROVAL_REQUIRED_FOR_INSTALLATION: 'custodian_approval_required_for_installation',\n  DEPRECATED_MANIFEST_VERSION: 'deprecated_manifest_version',\n  DISABLED: 'disabled',\n  ENABLED: 'enabled',\n  FORCE_INSTALLED: 'force_installed',\n  INSTALLABLE: 'installable',\n  REQUEST_PENDING: 'request_pending',\n  TERMINATED: 'terminated'\n}\n\nexport const MV2DeprecationStatus = {\n  INACTIVE: 'inactive',\n  SOFT_DISABLE: 'soft_disable',\n  WARNING: 'warning'\n}\n\nexport const Result = {\n  ALREADY_INSTALLED: 'already_installed',\n  BLACKLISTED: 'blacklisted',\n  BLOCKED_BY_POLICY: 'blocked_by_policy',\n  BLOCKED_FOR_CHILD_ACCOUNT: 'blocked_for_child_account',\n  FEATURE_DISABLED: 'feature_disabled',\n  ICON_ERROR: 'icon_error',\n  INSTALL_ERROR: 'install_error',\n  INSTALL_IN_PROGRESS: 'install_in_progress',\n  INVALID_ICON_URL: 'invalid_icon_url',\n  INVALID_ID: 'invalid_id',\n  LAUNCH_IN_PROGRESS: 'launch_in_progress',\n  MANIFEST_ERROR: 'manifest_error',\n  MISSING_DEPENDENCIES: 'missing_dependencies',\n  SUCCESS: 'success',\n  UNKNOWN_ERROR: 'unknown_error',\n  UNSUPPORTED_EXTENSION_TYPE: 'unsupported_extension_type',\n  USER_CANCELLED: 'user_cancelled',\n  USER_GESTURE_REQUIRED: 'user_gesture_required'\n}\n\nexport const WebGlStatus = {\n  WEBGL_ALLOWED: 'webgl_allowed',\n  WEBGL_BLOCKED: 'webgl_blocked'\n}\n", "import * as fs from 'node:fs'\nimport * as os from 'node:os'\nimport * as path from 'node:path'\nimport { Readable } from 'node:stream'\nimport { pipeline } from 'node:stream/promises'\nimport { session as electronSession } from 'electron'\n\nimport AdmZip from 'adm-zip'\nimport debug from 'debug'\nimport Pbf from 'pbf'\n\nimport { readCrxFileHeader, readSignedData } from './crx3'\nimport { convertHexadecimalToIDAlphabet, generateId } from './id'\nimport { fetch, getChromeVersion, getDefaultExtensionsPath } from './utils'\nimport { findExtensionInstall } from './loader'\nimport { ExtensionId } from './types'\n\nconst d = debug('electron-chrome-web-store:installer')\n\nfunction getExtensionCrxURL(extensionId: ExtensionId) {\n  const url = new URL('https://clients2.google.com/service/update2/crx')\n  url.searchParams.append('response', 'redirect')\n  url.searchParams.append('acceptformat', ['crx2', 'crx3'].join(','))\n\n  const x = new URLSearchParams()\n  x.append('id', extensionId)\n  x.append('uc', '')\n\n  url.searchParams.append('x', x.toString())\n  url.searchParams.append('prodversion', getChromeVersion())\n\n  return url.toString()\n}\n\ninterface CrxInfo {\n  extensionId: string\n  version: number\n  header: Buffer\n  contents: Buffer\n  publicKey: Buffer\n}\n\n// Parse CRX header and extract contents\nfunction parseCrx(buffer: Buffer): CrxInfo {\n  // CRX3 magic number: 'Cr24'\n  const magicNumber = buffer.toString('utf8', 0, 4)\n  if (magicNumber !== 'Cr24') {\n    throw new Error('Invalid CRX format')\n  }\n\n  // CRX3 format has version = 3 and header size at bytes 8-12\n  const version = buffer.readUInt32LE(4)\n  const headerSize = buffer.readUInt32LE(8)\n\n  // Extract header and contents\n  const header = buffer.subarray(12, 12 + headerSize)\n  const contents = buffer.subarray(12 + headerSize)\n\n  let extensionId: string\n  let publicKey: Buffer\n\n  // For CRX2 format\n  if (version === 2) {\n    const pubKeyLength = buffer.readUInt32LE(8)\n    const sigLength = buffer.readUInt32LE(12)\n    publicKey = buffer.subarray(16, 16 + pubKeyLength)\n    extensionId = generateId(publicKey.toString('base64'))\n  } else {\n    // For CRX3, extract public key from header\n    // CRX3 header contains a protocol buffer message\n    const crxFileHeader = readCrxFileHeader(new Pbf(header))\n    const crxSignedData = readSignedData(new Pbf(crxFileHeader.signed_header_data))\n    const declaredCrxId = crxSignedData.crx_id\n      ? convertHexadecimalToIDAlphabet(crxSignedData.crx_id.toString('hex'))\n      : null\n\n    if (!declaredCrxId) {\n      throw new Error('Invalid CRX signed data')\n    }\n\n    // Need to find store key proof which matches the declared ID\n    const keyProof = crxFileHeader.sha256_with_rsa.find((proof) => {\n      const crxId = proof.public_key ? generateId(proof.public_key.toString('base64')) : null\n      return crxId === declaredCrxId\n    })\n\n    if (!keyProof) {\n      throw new Error('Invalid CRX key')\n    }\n\n    extensionId = declaredCrxId\n    publicKey = keyProof.public_key\n  }\n\n  return {\n    extensionId,\n    version,\n    header,\n    contents,\n    publicKey\n  }\n}\n\n// Extract CRX contents and update manifest\nasync function unpackCrx(crx: CrxInfo, destPath: string): Promise<chrome.runtime.Manifest> {\n  // Create zip file from contents\n  const zip = new AdmZip(crx.contents)\n\n  // Extract zip to destination\n  zip.extractAllTo(destPath, true)\n\n  // Read manifest.json\n  const manifestPath = path.join(destPath, 'manifest.json')\n  const manifestContent = await fs.promises.readFile(manifestPath, 'utf8')\n  const manifest = JSON.parse(manifestContent) as chrome.runtime.Manifest\n\n  // Add public key to manifest\n  manifest.key = crx.publicKey.toString('base64')\n\n  // Write updated manifest back\n  await fs.promises.writeFile(manifestPath, JSON.stringify(manifest, null, 2))\n\n  return manifest\n}\n\nasync function readCrx(crxPath: string) {\n  const crxBuffer = await fs.promises.readFile(crxPath)\n  return parseCrx(crxBuffer)\n}\n\nasync function downloadCrx(url: string, dest: string) {\n  const response = await fetch(url)\n  if (!response.ok) {\n    throw new Error('Failed to download extension')\n  }\n\n  const fileStream = fs.createWriteStream(dest)\n  const downloadStream = Readable.fromWeb(response.body as any)\n  await pipeline(downloadStream, fileStream)\n}\n\nexport async function downloadExtensionFromURL(\n  url: string,\n  extensionsDir: string,\n  expectedExtensionId?: string\n): Promise<string> {\n  d('downloading %s', url)\n\n  const installUuid = crypto.randomUUID()\n  const crxPath = path.join(os.tmpdir(), `electron-cws-download_${installUuid}.crx`)\n  try {\n    await downloadCrx(url, crxPath)\n\n    const crx = await readCrx(crxPath)\n\n    if (expectedExtensionId && expectedExtensionId !== crx.extensionId) {\n      throw new Error(\n        `CRX mismatches expected extension ID: ${expectedExtensionId} !== ${crx.extensionId}`\n      )\n    }\n\n    const unpackedPath = path.join(extensionsDir, crx.extensionId, installUuid)\n    await fs.promises.mkdir(unpackedPath, { recursive: true })\n    const manifest = await unpackCrx(crx, unpackedPath)\n\n    if (!manifest.version) {\n      throw new Error('Installed extension is missing manifest version')\n    }\n\n    const versionedPath = path.join(extensionsDir, crx.extensionId, `${manifest.version}_0`)\n    await fs.promises.rename(unpackedPath, versionedPath)\n\n    return versionedPath\n  } finally {\n    await fs.promises.rm(crxPath, { force: true })\n  }\n}\n\n/**\n * Download and unpack extension to the given extensions directory.\n */\nexport async function downloadExtension(\n  extensionId: string,\n  extensionsDir: string\n): Promise<string> {\n  const url = getExtensionCrxURL(extensionId)\n  return await downloadExtensionFromURL(url, extensionsDir, extensionId)\n}\n\ninterface CommonExtensionOptions {\n  /** Session to load extensions into. */\n  session?: Electron.Session\n\n  /**\n   * Directory where web store extensions will be installed.\n   * Defaults to `Extensions` under the app's `userData` directory.\n   */\n  extensionsPath?: string\n}\n\ninterface InstallExtensionOptions extends CommonExtensionOptions {\n  /** Options for loading the extension. */\n  loadExtensionOptions?: Electron.LoadExtensionOptions\n}\n\ninterface UninstallExtensionOptions extends CommonExtensionOptions {}\n\n/**\n * Install extension from the web store.\n */\nexport async function installExtension(\n  extensionId: string,\n  opts: InstallExtensionOptions = {}\n): Promise<Electron.Extension> {\n  d('installing %s', extensionId)\n\n  const session = opts.session || electronSession.defaultSession\n  const sessionExtensions = session.extensions || session\n  const extensionsPath = opts.extensionsPath || getDefaultExtensionsPath()\n\n  // Check if already loaded\n  const existingExtension = sessionExtensions.getExtension(extensionId)\n  if (existingExtension) {\n    d('%s already loaded', extensionId)\n    return existingExtension\n  }\n\n  // Check if already installed\n  const existingExtensionInfo = await findExtensionInstall(extensionId, extensionsPath)\n  if (existingExtensionInfo && existingExtensionInfo.type === 'store') {\n    d('%s already installed', extensionId)\n    return await sessionExtensions.loadExtension(\n      existingExtensionInfo.path,\n      opts.loadExtensionOptions\n    )\n  }\n\n  // Download and load new extension\n  const extensionPath = await downloadExtension(extensionId, extensionsPath)\n  const extension = await sessionExtensions.loadExtension(extensionPath, opts.loadExtensionOptions)\n  d('installed %s', extensionId)\n\n  return extension\n}\n\n/**\n * Uninstall extension from the web store.\n */\nexport async function uninstallExtension(\n  extensionId: string,\n  opts: UninstallExtensionOptions = {}\n) {\n  d('uninstalling %s', extensionId)\n\n  const session = opts.session || electronSession.defaultSession\n  const sessionExtensions = session.extensions || session\n  const extensionsPath = opts.extensionsPath || getDefaultExtensionsPath()\n\n  const extensions = sessionExtensions.getAllExtensions()\n  const existingExt = extensions.find((ext) => ext.id === extensionId)\n  if (existingExt) {\n    sessionExtensions.removeExtension(extensionId)\n  }\n\n  const extensionDir = path.join(extensionsPath, extensionId)\n  try {\n    const stat = await fs.promises.stat(extensionDir)\n    if (stat.isDirectory()) {\n      await fs.promises.rm(extensionDir, { recursive: true, force: true })\n    }\n  } catch (error: any) {\n    if (error?.code !== 'ENOENT') {\n      throw error\n    }\n  }\n}\n", "\nconst SHIFT_LEFT_32 = (1 << 16) * (1 << 16);\nconst SHIFT_RIGHT_32 = 1 / SHIFT_LEFT_32;\n\n// Threshold chosen based on both benchmarking and knowledge about browser string\n// data structures (which currently switch structure types at 12 bytes or more)\nconst TEXT_DECODER_MIN_LENGTH = 12;\nconst utf8TextDecoder = typeof TextDecoder === 'undefined' ? null : new TextDecoder('utf-8');\n\nconst PBF_VARINT  = 0; // varint: int32, int64, uint32, uint64, sint32, sint64, bool, enum\nconst PBF_FIXED64 = 1; // 64-bit: double, fixed64, sfixed64\nconst PBF_BYTES   = 2; // length-delimited: string, bytes, embedded messages, packed repeated fields\nconst PBF_FIXED32 = 5; // 32-bit: float, fixed32, sfixed32\n\nexport default class Pbf {\n    /**\n     * @param {Uint8Array | ArrayBuffer} [buf]\n     */\n    constructor(buf = new Uint8Array(16)) {\n        this.buf = ArrayBuffer.isView(buf) ? buf : new Uint8Array(buf);\n        this.dataView = new DataView(this.buf.buffer);\n        this.pos = 0;\n        this.type = 0;\n        this.length = this.buf.length;\n    }\n\n    // === READING =================================================================\n\n    /**\n     * @template T\n     * @param {(tag: number, result: T, pbf: Pbf) => void} readField\n     * @param {T} result\n     * @param {number} [end]\n     */\n    readFields(readField, result, end = this.length) {\n        while (this.pos < end) {\n            const val = this.readVarint(),\n                tag = val >> 3,\n                startPos = this.pos;\n\n            this.type = val & 0x7;\n            readField(tag, result, this);\n\n            if (this.pos === startPos) this.skip(val);\n        }\n        return result;\n    }\n\n    /**\n     * @template T\n     * @param {(tag: number, result: T, pbf: Pbf) => void} readField\n     * @param {T} result\n     */\n    readMessage(readField, result) {\n        return this.readFields(readField, result, this.readVarint() + this.pos);\n    }\n\n    readFixed32() {\n        const val = this.dataView.getUint32(this.pos, true);\n        this.pos += 4;\n        return val;\n    }\n\n    readSFixed32() {\n        const val = this.dataView.getInt32(this.pos, true);\n        this.pos += 4;\n        return val;\n    }\n\n    // 64-bit int handling is based on github.com/dpw/node-buffer-more-ints (MIT-licensed)\n\n    readFixed64() {\n        const val = this.dataView.getUint32(this.pos, true) + this.dataView.getUint32(this.pos + 4, true) * SHIFT_LEFT_32;\n        this.pos += 8;\n        return val;\n    }\n\n    readSFixed64() {\n        const val = this.dataView.getUint32(this.pos, true) + this.dataView.getInt32(this.pos + 4, true) * SHIFT_LEFT_32;\n        this.pos += 8;\n        return val;\n    }\n\n    readFloat() {\n        const val = this.dataView.getFloat32(this.pos, true);\n        this.pos += 4;\n        return val;\n    }\n\n    readDouble() {\n        const val = this.dataView.getFloat64(this.pos, true);\n        this.pos += 8;\n        return val;\n    }\n\n    /**\n     * @param {boolean} [isSigned]\n     */\n    readVarint(isSigned) {\n        const buf = this.buf;\n        let val, b;\n\n        b = buf[this.pos++]; val  =  b & 0x7f;        if (b < 0x80) return val;\n        b = buf[this.pos++]; val |= (b & 0x7f) << 7;  if (b < 0x80) return val;\n        b = buf[this.pos++]; val |= (b & 0x7f) << 14; if (b < 0x80) return val;\n        b = buf[this.pos++]; val |= (b & 0x7f) << 21; if (b < 0x80) return val;\n        b = buf[this.pos];   val |= (b & 0x0f) << 28;\n\n        return readVarintRemainder(val, isSigned, this);\n    }\n\n    readVarint64() { // for compatibility with v2.0.1\n        return this.readVarint(true);\n    }\n\n    readSVarint() {\n        const num = this.readVarint();\n        return num % 2 === 1 ? (num + 1) / -2 : num / 2; // zigzag encoding\n    }\n\n    readBoolean() {\n        return Boolean(this.readVarint());\n    }\n\n    readString() {\n        const end = this.readVarint() + this.pos;\n        const pos = this.pos;\n        this.pos = end;\n\n        if (end - pos >= TEXT_DECODER_MIN_LENGTH && utf8TextDecoder) {\n            // longer strings are fast with the built-in browser TextDecoder API\n            return utf8TextDecoder.decode(this.buf.subarray(pos, end));\n        }\n        // short strings are fast with our custom implementation\n        return readUtf8(this.buf, pos, end);\n    }\n\n    readBytes() {\n        const end = this.readVarint() + this.pos,\n            buffer = this.buf.subarray(this.pos, end);\n        this.pos = end;\n        return buffer;\n    }\n\n    // verbose for performance reasons; doesn't affect gzipped size\n\n    /**\n     * @param {number[]} [arr]\n     * @param {boolean} [isSigned]\n     */\n    readPackedVarint(arr = [], isSigned) {\n        const end = this.readPackedEnd();\n        while (this.pos < end) arr.push(this.readVarint(isSigned));\n        return arr;\n    }\n    /** @param {number[]} [arr] */\n    readPackedSVarint(arr = []) {\n        const end = this.readPackedEnd();\n        while (this.pos < end) arr.push(this.readSVarint());\n        return arr;\n    }\n    /** @param {boolean[]} [arr] */\n    readPackedBoolean(arr = []) {\n        const end = this.readPackedEnd();\n        while (this.pos < end) arr.push(this.readBoolean());\n        return arr;\n    }\n    /** @param {number[]} [arr] */\n    readPackedFloat(arr = []) {\n        const end = this.readPackedEnd();\n        while (this.pos < end) arr.push(this.readFloat());\n        return arr;\n    }\n    /** @param {number[]} [arr] */\n    readPackedDouble(arr = []) {\n        const end = this.readPackedEnd();\n        while (this.pos < end) arr.push(this.readDouble());\n        return arr;\n    }\n    /** @param {number[]} [arr] */\n    readPackedFixed32(arr = []) {\n        const end = this.readPackedEnd();\n        while (this.pos < end) arr.push(this.readFixed32());\n        return arr;\n    }\n    /** @param {number[]} [arr] */\n    readPackedSFixed32(arr = []) {\n        const end = this.readPackedEnd();\n        while (this.pos < end) arr.push(this.readSFixed32());\n        return arr;\n    }\n    /** @param {number[]} [arr] */\n    readPackedFixed64(arr = []) {\n        const end = this.readPackedEnd();\n        while (this.pos < end) arr.push(this.readFixed64());\n        return arr;\n    }\n    /** @param {number[]} [arr] */\n    readPackedSFixed64(arr = []) {\n        const end = this.readPackedEnd();\n        while (this.pos < end) arr.push(this.readSFixed64());\n        return arr;\n    }\n    readPackedEnd() {\n        return this.type === PBF_BYTES ? this.readVarint() + this.pos : this.pos + 1;\n    }\n\n    /** @param {number} val */\n    skip(val) {\n        const type = val & 0x7;\n        if (type === PBF_VARINT) while (this.buf[this.pos++] > 0x7f) {}\n        else if (type === PBF_BYTES) this.pos = this.readVarint() + this.pos;\n        else if (type === PBF_FIXED32) this.pos += 4;\n        else if (type === PBF_FIXED64) this.pos += 8;\n        else throw new Error(`Unimplemented type: ${type}`);\n    }\n\n    // === WRITING =================================================================\n\n    /**\n     * @param {number} tag\n     * @param {number} type\n     */\n    writeTag(tag, type) {\n        this.writeVarint((tag << 3) | type);\n    }\n\n    /** @param {number} min */\n    realloc(min) {\n        let length = this.length || 16;\n\n        while (length < this.pos + min) length *= 2;\n\n        if (length !== this.length) {\n            const buf = new Uint8Array(length);\n            buf.set(this.buf);\n            this.buf = buf;\n            this.dataView = new DataView(buf.buffer);\n            this.length = length;\n        }\n    }\n\n    finish() {\n        this.length = this.pos;\n        this.pos = 0;\n        return this.buf.subarray(0, this.length);\n    }\n\n    /** @param {number} val */\n    writeFixed32(val) {\n        this.realloc(4);\n        this.dataView.setInt32(this.pos, val, true);\n        this.pos += 4;\n    }\n\n    /** @param {number} val */\n    writeSFixed32(val) {\n        this.realloc(4);\n        this.dataView.setInt32(this.pos, val, true);\n        this.pos += 4;\n    }\n\n    /** @param {number} val */\n    writeFixed64(val) {\n        this.realloc(8);\n        this.dataView.setInt32(this.pos, val & -1, true);\n        this.dataView.setInt32(this.pos + 4, Math.floor(val * SHIFT_RIGHT_32), true);\n        this.pos += 8;\n    }\n\n    /** @param {number} val */\n    writeSFixed64(val) {\n        this.realloc(8);\n        this.dataView.setInt32(this.pos, val & -1, true);\n        this.dataView.setInt32(this.pos + 4, Math.floor(val * SHIFT_RIGHT_32), true);\n        this.pos += 8;\n    }\n\n    /** @param {number} val */\n    writeVarint(val) {\n        val = +val || 0;\n\n        if (val > 0xfffffff || val < 0) {\n            writeBigVarint(val, this);\n            return;\n        }\n\n        this.realloc(4);\n\n        this.buf[this.pos++] =           val & 0x7f  | (val > 0x7f ? 0x80 : 0); if (val <= 0x7f) return;\n        this.buf[this.pos++] = ((val >>>= 7) & 0x7f) | (val > 0x7f ? 0x80 : 0); if (val <= 0x7f) return;\n        this.buf[this.pos++] = ((val >>>= 7) & 0x7f) | (val > 0x7f ? 0x80 : 0); if (val <= 0x7f) return;\n        this.buf[this.pos++] =   (val >>> 7) & 0x7f;\n    }\n\n    /** @param {number} val */\n    writeSVarint(val) {\n        this.writeVarint(val < 0 ? -val * 2 - 1 : val * 2);\n    }\n\n    /** @param {boolean} val */\n    writeBoolean(val) {\n        this.writeVarint(+val);\n    }\n\n    /** @param {string} str */\n    writeString(str) {\n        str = String(str);\n        this.realloc(str.length * 4);\n\n        this.pos++; // reserve 1 byte for short string length\n\n        const startPos = this.pos;\n        // write the string directly to the buffer and see how much was written\n        this.pos = writeUtf8(this.buf, str, this.pos);\n        const len = this.pos - startPos;\n\n        if (len >= 0x80) makeRoomForExtraLength(startPos, len, this);\n\n        // finally, write the message length in the reserved place and restore the position\n        this.pos = startPos - 1;\n        this.writeVarint(len);\n        this.pos += len;\n    }\n\n    /** @param {number} val */\n    writeFloat(val) {\n        this.realloc(4);\n        this.dataView.setFloat32(this.pos, val, true);\n        this.pos += 4;\n    }\n\n    /** @param {number} val */\n    writeDouble(val) {\n        this.realloc(8);\n        this.dataView.setFloat64(this.pos, val, true);\n        this.pos += 8;\n    }\n\n    /** @param {Uint8Array} buffer */\n    writeBytes(buffer) {\n        const len = buffer.length;\n        this.writeVarint(len);\n        this.realloc(len);\n        for (let i = 0; i < len; i++) this.buf[this.pos++] = buffer[i];\n    }\n\n    /**\n     * @template T\n     * @param {(obj: T, pbf: Pbf) => void} fn\n     * @param {T} obj\n     */\n    writeRawMessage(fn, obj) {\n        this.pos++; // reserve 1 byte for short message length\n\n        // write the message directly to the buffer and see how much was written\n        const startPos = this.pos;\n        fn(obj, this);\n        const len = this.pos - startPos;\n\n        if (len >= 0x80) makeRoomForExtraLength(startPos, len, this);\n\n        // finally, write the message length in the reserved place and restore the position\n        this.pos = startPos - 1;\n        this.writeVarint(len);\n        this.pos += len;\n    }\n\n    /**\n     * @template T\n     * @param {number} tag\n     * @param {(obj: T, pbf: Pbf) => void} fn\n     * @param {T} obj\n     */\n    writeMessage(tag, fn, obj) {\n        this.writeTag(tag, PBF_BYTES);\n        this.writeRawMessage(fn, obj);\n    }\n\n    /**\n     * @param {number} tag\n     * @param {number[]} arr\n     */\n    writePackedVarint(tag, arr) {\n        if (arr.length) this.writeMessage(tag, writePackedVarint, arr);\n    }\n    /**\n     * @param {number} tag\n     * @param {number[]} arr\n     */\n    writePackedSVarint(tag, arr) {\n        if (arr.length) this.writeMessage(tag, writePackedSVarint, arr);\n    }\n    /**\n     * @param {number} tag\n     * @param {boolean[]} arr\n     */\n    writePackedBoolean(tag, arr) {\n        if (arr.length) this.writeMessage(tag, writePackedBoolean, arr);\n    }\n    /**\n     * @param {number} tag\n     * @param {number[]} arr\n     */\n    writePackedFloat(tag, arr) {\n        if (arr.length) this.writeMessage(tag, writePackedFloat, arr);\n    }\n    /**\n     * @param {number} tag\n     * @param {number[]} arr\n     */\n    writePackedDouble(tag, arr) {\n        if (arr.length) this.writeMessage(tag, writePackedDouble, arr);\n    }\n    /**\n     * @param {number} tag\n     * @param {number[]} arr\n     */\n    writePackedFixed32(tag, arr) {\n        if (arr.length) this.writeMessage(tag, writePackedFixed32, arr);\n    }\n    /**\n     * @param {number} tag\n     * @param {number[]} arr\n     */\n    writePackedSFixed32(tag, arr) {\n        if (arr.length) this.writeMessage(tag, writePackedSFixed32, arr);\n    }\n    /**\n     * @param {number} tag\n     * @param {number[]} arr\n     */\n    writePackedFixed64(tag, arr) {\n        if (arr.length) this.writeMessage(tag, writePackedFixed64, arr);\n    }\n    /**\n     * @param {number} tag\n     * @param {number[]} arr\n     */\n    writePackedSFixed64(tag, arr) {\n        if (arr.length) this.writeMessage(tag, writePackedSFixed64, arr);\n    }\n\n    /**\n     * @param {number} tag\n     * @param {Uint8Array} buffer\n     */\n    writeBytesField(tag, buffer) {\n        this.writeTag(tag, PBF_BYTES);\n        this.writeBytes(buffer);\n    }\n    /**\n     * @param {number} tag\n     * @param {number} val\n     */\n    writeFixed32Field(tag, val) {\n        this.writeTag(tag, PBF_FIXED32);\n        this.writeFixed32(val);\n    }\n    /**\n     * @param {number} tag\n     * @param {number} val\n     */\n    writeSFixed32Field(tag, val) {\n        this.writeTag(tag, PBF_FIXED32);\n        this.writeSFixed32(val);\n    }\n    /**\n     * @param {number} tag\n     * @param {number} val\n     */\n    writeFixed64Field(tag, val) {\n        this.writeTag(tag, PBF_FIXED64);\n        this.writeFixed64(val);\n    }\n    /**\n     * @param {number} tag\n     * @param {number} val\n     */\n    writeSFixed64Field(tag, val) {\n        this.writeTag(tag, PBF_FIXED64);\n        this.writeSFixed64(val);\n    }\n    /**\n     * @param {number} tag\n     * @param {number} val\n     */\n    writeVarintField(tag, val) {\n        this.writeTag(tag, PBF_VARINT);\n        this.writeVarint(val);\n    }\n    /**\n     * @param {number} tag\n     * @param {number} val\n     */\n    writeSVarintField(tag, val) {\n        this.writeTag(tag, PBF_VARINT);\n        this.writeSVarint(val);\n    }\n    /**\n     * @param {number} tag\n     * @param {string} str\n     */\n    writeStringField(tag, str) {\n        this.writeTag(tag, PBF_BYTES);\n        this.writeString(str);\n    }\n    /**\n     * @param {number} tag\n     * @param {number} val\n     */\n    writeFloatField(tag, val) {\n        this.writeTag(tag, PBF_FIXED32);\n        this.writeFloat(val);\n    }\n    /**\n     * @param {number} tag\n     * @param {number} val\n     */\n    writeDoubleField(tag, val) {\n        this.writeTag(tag, PBF_FIXED64);\n        this.writeDouble(val);\n    }\n    /**\n     * @param {number} tag\n     * @param {boolean} val\n     */\n    writeBooleanField(tag, val) {\n        this.writeVarintField(tag, +val);\n    }\n};\n\n/**\n * @param {number} l\n * @param {boolean | undefined} s\n * @param {Pbf} p\n */\nfunction readVarintRemainder(l, s, p) {\n    const buf = p.buf;\n    let h, b;\n\n    b = buf[p.pos++]; h  = (b & 0x70) >> 4;  if (b < 0x80) return toNum(l, h, s);\n    b = buf[p.pos++]; h |= (b & 0x7f) << 3;  if (b < 0x80) return toNum(l, h, s);\n    b = buf[p.pos++]; h |= (b & 0x7f) << 10; if (b < 0x80) return toNum(l, h, s);\n    b = buf[p.pos++]; h |= (b & 0x7f) << 17; if (b < 0x80) return toNum(l, h, s);\n    b = buf[p.pos++]; h |= (b & 0x7f) << 24; if (b < 0x80) return toNum(l, h, s);\n    b = buf[p.pos++]; h |= (b & 0x01) << 31; if (b < 0x80) return toNum(l, h, s);\n\n    throw new Error('Expected varint not more than 10 bytes');\n}\n\n/**\n * @param {number} low\n * @param {number} high\n * @param {boolean} [isSigned]\n */\nfunction toNum(low, high, isSigned) {\n    return isSigned ? high * 0x100000000 + (low >>> 0) : ((high >>> 0) * 0x100000000) + (low >>> 0);\n}\n\n/**\n * @param {number} val\n * @param {Pbf} pbf\n */\nfunction writeBigVarint(val, pbf) {\n    let low, high;\n\n    if (val >= 0) {\n        low  = (val % 0x100000000) | 0;\n        high = (val / 0x100000000) | 0;\n    } else {\n        low  = ~(-val % 0x100000000);\n        high = ~(-val / 0x100000000);\n\n        if (low ^ 0xffffffff) {\n            low = (low + 1) | 0;\n        } else {\n            low = 0;\n            high = (high + 1) | 0;\n        }\n    }\n\n    if (val >= 0x10000000000000000 || val < -0x10000000000000000) {\n        throw new Error('Given varint doesn\\'t fit into 10 bytes');\n    }\n\n    pbf.realloc(10);\n\n    writeBigVarintLow(low, high, pbf);\n    writeBigVarintHigh(high, pbf);\n}\n\n/**\n * @param {number} high\n * @param {number} low\n * @param {Pbf} pbf\n */\nfunction writeBigVarintLow(low, high, pbf) {\n    pbf.buf[pbf.pos++] = low & 0x7f | 0x80; low >>>= 7;\n    pbf.buf[pbf.pos++] = low & 0x7f | 0x80; low >>>= 7;\n    pbf.buf[pbf.pos++] = low & 0x7f | 0x80; low >>>= 7;\n    pbf.buf[pbf.pos++] = low & 0x7f | 0x80; low >>>= 7;\n    pbf.buf[pbf.pos]   = low & 0x7f;\n}\n\n/**\n * @param {number} high\n * @param {Pbf} pbf\n */\nfunction writeBigVarintHigh(high, pbf) {\n    const lsb = (high & 0x07) << 4;\n\n    pbf.buf[pbf.pos++] |= lsb         | ((high >>>= 3) ? 0x80 : 0); if (!high) return;\n    pbf.buf[pbf.pos++]  = high & 0x7f | ((high >>>= 7) ? 0x80 : 0); if (!high) return;\n    pbf.buf[pbf.pos++]  = high & 0x7f | ((high >>>= 7) ? 0x80 : 0); if (!high) return;\n    pbf.buf[pbf.pos++]  = high & 0x7f | ((high >>>= 7) ? 0x80 : 0); if (!high) return;\n    pbf.buf[pbf.pos++]  = high & 0x7f | ((high >>>= 7) ? 0x80 : 0); if (!high) return;\n    pbf.buf[pbf.pos++]  = high & 0x7f;\n}\n\n/**\n * @param {number} startPos\n * @param {number} len\n * @param {Pbf} pbf\n */\nfunction makeRoomForExtraLength(startPos, len, pbf) {\n    const extraLen =\n        len <= 0x3fff ? 1 :\n        len <= 0x1fffff ? 2 :\n        len <= 0xfffffff ? 3 : Math.floor(Math.log(len) / (Math.LN2 * 7));\n\n    // if 1 byte isn't enough for encoding message length, shift the data to the right\n    pbf.realloc(extraLen);\n    for (let i = pbf.pos - 1; i >= startPos; i--) pbf.buf[i + extraLen] = pbf.buf[i];\n}\n\n/**\n * @param {number[]} arr\n * @param {Pbf} pbf\n */\nfunction writePackedVarint(arr, pbf) {\n    for (let i = 0; i < arr.length; i++) pbf.writeVarint(arr[i]);\n}\n/**\n * @param {number[]} arr\n * @param {Pbf} pbf\n */\nfunction writePackedSVarint(arr, pbf) {\n    for (let i = 0; i < arr.length; i++) pbf.writeSVarint(arr[i]);\n}\n/**\n * @param {number[]} arr\n * @param {Pbf} pbf\n */\nfunction writePackedFloat(arr, pbf) {\n    for (let i = 0; i < arr.length; i++) pbf.writeFloat(arr[i]);\n}\n/**\n * @param {number[]} arr\n * @param {Pbf} pbf\n */\nfunction writePackedDouble(arr, pbf) {\n    for (let i = 0; i < arr.length; i++) pbf.writeDouble(arr[i]);\n}\n/**\n * @param {boolean[]} arr\n * @param {Pbf} pbf\n */\nfunction writePackedBoolean(arr, pbf) {\n    for (let i = 0; i < arr.length; i++) pbf.writeBoolean(arr[i]);\n}\n/**\n * @param {number[]} arr\n * @param {Pbf} pbf\n */\nfunction writePackedFixed32(arr, pbf) {\n    for (let i = 0; i < arr.length; i++) pbf.writeFixed32(arr[i]);\n}\n/**\n * @param {number[]} arr\n * @param {Pbf} pbf\n */\nfunction writePackedSFixed32(arr, pbf) {\n    for (let i = 0; i < arr.length; i++) pbf.writeSFixed32(arr[i]);\n}\n/**\n * @param {number[]} arr\n * @param {Pbf} pbf\n */\nfunction writePackedFixed64(arr, pbf) {\n    for (let i = 0; i < arr.length; i++) pbf.writeFixed64(arr[i]);\n}\n/**\n * @param {number[]} arr\n * @param {Pbf} pbf\n */\nfunction writePackedSFixed64(arr, pbf) {\n    for (let i = 0; i < arr.length; i++) pbf.writeSFixed64(arr[i]);\n}\n\n// Buffer code below from https://github.com/feross/buffer, MIT-licensed\n\n/**\n * @param {Uint8Array} buf\n * @param {number} pos\n * @param {number} end\n */\nfunction readUtf8(buf, pos, end) {\n    let str = '';\n    let i = pos;\n\n    while (i < end) {\n        const b0 = buf[i];\n        let c = null; // codepoint\n        let bytesPerSequence =\n            b0 > 0xEF ? 4 :\n            b0 > 0xDF ? 3 :\n            b0 > 0xBF ? 2 : 1;\n\n        if (i + bytesPerSequence > end) break;\n\n        let b1, b2, b3;\n\n        if (bytesPerSequence === 1) {\n            if (b0 < 0x80) {\n                c = b0;\n            }\n        } else if (bytesPerSequence === 2) {\n            b1 = buf[i + 1];\n            if ((b1 & 0xC0) === 0x80) {\n                c = (b0 & 0x1F) << 0x6 | (b1 & 0x3F);\n                if (c <= 0x7F) {\n                    c = null;\n                }\n            }\n        } else if (bytesPerSequence === 3) {\n            b1 = buf[i + 1];\n            b2 = buf[i + 2];\n            if ((b1 & 0xC0) === 0x80 && (b2 & 0xC0) === 0x80) {\n                c = (b0 & 0xF) << 0xC | (b1 & 0x3F) << 0x6 | (b2 & 0x3F);\n                if (c <= 0x7FF || (c >= 0xD800 && c <= 0xDFFF)) {\n                    c = null;\n                }\n            }\n        } else if (bytesPerSequence === 4) {\n            b1 = buf[i + 1];\n            b2 = buf[i + 2];\n            b3 = buf[i + 3];\n            if ((b1 & 0xC0) === 0x80 && (b2 & 0xC0) === 0x80 && (b3 & 0xC0) === 0x80) {\n                c = (b0 & 0xF) << 0x12 | (b1 & 0x3F) << 0xC | (b2 & 0x3F) << 0x6 | (b3 & 0x3F);\n                if (c <= 0xFFFF || c >= 0x110000) {\n                    c = null;\n                }\n            }\n        }\n\n        if (c === null) {\n            c = 0xFFFD;\n            bytesPerSequence = 1;\n\n        } else if (c > 0xFFFF) {\n            c -= 0x10000;\n            str += String.fromCharCode(c >>> 10 & 0x3FF | 0xD800);\n            c = 0xDC00 | c & 0x3FF;\n        }\n\n        str += String.fromCharCode(c);\n        i += bytesPerSequence;\n    }\n\n    return str;\n}\n\n/**\n * @param {Uint8Array} buf\n * @param {string} str\n * @param {number} pos\n */\nfunction writeUtf8(buf, str, pos) {\n    for (let i = 0, c, lead; i < str.length; i++) {\n        c = str.charCodeAt(i); // code point\n\n        if (c > 0xD7FF && c < 0xE000) {\n            if (lead) {\n                if (c < 0xDC00) {\n                    buf[pos++] = 0xEF;\n                    buf[pos++] = 0xBF;\n                    buf[pos++] = 0xBD;\n                    lead = c;\n                    continue;\n                } else {\n                    c = lead - 0xD800 << 10 | c - 0xDC00 | 0x10000;\n                    lead = null;\n                }\n            } else {\n                if (c > 0xDBFF || (i + 1 === str.length)) {\n                    buf[pos++] = 0xEF;\n                    buf[pos++] = 0xBF;\n                    buf[pos++] = 0xBD;\n                } else {\n                    lead = c;\n                }\n                continue;\n            }\n        } else if (lead) {\n            buf[pos++] = 0xEF;\n            buf[pos++] = 0xBF;\n            buf[pos++] = 0xBD;\n            lead = null;\n        }\n\n        if (c < 0x80) {\n            buf[pos++] = c;\n        } else {\n            if (c < 0x800) {\n                buf[pos++] = c >> 0x6 | 0xC0;\n            } else {\n                if (c < 0x10000) {\n                    buf[pos++] = c >> 0xC | 0xE0;\n                } else {\n                    buf[pos++] = c >> 0x12 | 0xF0;\n                    buf[pos++] = c >> 0xC & 0x3F | 0x80;\n                }\n                buf[pos++] = c >> 0x6 & 0x3F | 0x80;\n            }\n            buf[pos++] = c & 0x3F | 0x80;\n        }\n    }\n    return pos;\n}\n", "// code generated by pbf v4.0.1\n// modified for electron-chrome-web-store\n\nimport Pbf from 'pbf'\n\ninterface AsymmetricKeyProof {\n  public_key: Buffer\n  signature: Buffer\n}\n\ninterface CrxFileHeader {\n  sha256_with_rsa: AsymmetricKeyProof[]\n  sha256_with_ecdsa: AsymmetricKeyProof[]\n  verified_contents?: Buffer\n  signed_header_data?: Buffer\n}\n\nexport function readCrxFileHeader(pbf: Pbf, end?: any): CrxFileHeader {\n  return pbf.readFields(\n    readCrxFileHeaderField,\n    {\n      sha256_with_rsa: [],\n      sha256_with_ecdsa: [],\n      verified_contents: undefined,\n      signed_header_data: undefined\n    },\n    end\n  )\n}\nfunction readCrxFileHeaderField(tag: any, obj: any, pbf: Pbf) {\n  if (tag === 2) obj.sha256_with_rsa.push(readAsymmetricKeyProof(pbf, pbf.readVarint() + pbf.pos))\n  else if (tag === 3)\n    obj.sha256_with_ecdsa.push(readAsymmetricKeyProof(pbf, pbf.readVarint() + pbf.pos))\n  else if (tag === 4) obj.verified_contents = pbf.readBytes()\n  else if (tag === 10000) obj.signed_header_data = pbf.readBytes()\n}\n\nexport function readAsymmetricKeyProof(pbf: Pbf, end: any) {\n  return pbf.readFields(\n    readAsymmetricKeyProofField,\n    { public_key: undefined, signature: undefined },\n    end\n  )\n}\nfunction readAsymmetricKeyProofField(tag: any, obj: any, pbf: Pbf) {\n  if (tag === 1) obj.public_key = pbf.readBytes()\n  else if (tag === 2) obj.signature = pbf.readBytes()\n}\n\nexport function readSignedData(pbf: Pbf, end?: any): { crx_id?: Buffer } {\n  return pbf.readFields(readSignedDataField, { crx_id: undefined }, end)\n}\nfunction readSignedDataField(tag: any, obj: any, pbf: Pbf) {\n  if (tag === 1) obj.crx_id = pbf.readBytes()\n}\n", "import { createHash } from 'node:crypto'\n\n/**\n * Converts a normal hexadecimal string into the alphabet used by extensions.\n * We use the characters 'a'-'p' instead of '0'-'f' to avoid ever having a\n * completely numeric host, since some software interprets that as an IP address.\n *\n * @param id - The hexadecimal string to convert. This is modified in place.\n */\nexport function convertHexadecimalToIDAlphabet(id: string) {\n  let result = ''\n  for (const ch of id) {\n    const val = parseInt(ch, 16)\n    if (!isNaN(val)) {\n      result += String.fromCharCode('a'.charCodeAt(0) + val)\n    } else {\n      result += 'a'\n    }\n  }\n  return result\n}\n\nfunction generateIdFromHash(hash: Buffer): string {\n  const hashedId = hash.subarray(0, 16).toString('hex')\n  return convertHexadecimalToIDAlphabet(hashedId)\n}\n\nexport function generateId(input: string): string {\n  const hash = createHash('sha256').update(input, 'base64').digest()\n  return generateIdFromHash(hash)\n}\n", "import * as fs from 'node:fs'\nimport * as path from 'node:path'\nimport debug from 'debug'\n\nimport { generateId } from './id'\nimport { compareVersions } from './utils'\nimport { ExtensionId } from './types'\n\nconst d = debug('electron-chrome-web-store:loader')\n\ntype ExtensionPathBaseInfo = { manifest: chrome.runtime.Manifest; path: string }\ntype ExtensionPathInfo =\n  | ({ type: 'store'; id: string } & ExtensionPathBaseInfo)\n  | ({ type: 'unpacked' } & ExtensionPathBaseInfo)\n\nconst manifestExists = async (dirPath: string) => {\n  if (!dirPath) return false\n  const manifestPath = path.join(dirPath, 'manifest.json')\n  try {\n    return (await fs.promises.stat(manifestPath)).isFile()\n  } catch {\n    return false\n  }\n}\n\n/**\n * DFS directories for extension manifests.\n */\nasync function extensionSearch(dirPath: string, depth: number = 0): Promise<string[]> {\n  if (depth >= 2) return []\n  const results = []\n  const dirEntries = await fs.promises.readdir(dirPath, { withFileTypes: true })\n  for (const entry of dirEntries) {\n    if (entry.isDirectory()) {\n      if (await manifestExists(path.join(dirPath, entry.name))) {\n        results.push(path.join(dirPath, entry.name))\n      } else {\n        results.push(...(await extensionSearch(path.join(dirPath, entry.name), depth + 1)))\n      }\n    }\n  }\n  return results\n}\n\n/**\n * Discover list of extensions in the given path.\n */\nasync function discoverExtensions(extensionsPath: string): Promise<ExtensionPathInfo[]> {\n  try {\n    const stat = await fs.promises.stat(extensionsPath)\n    if (!stat.isDirectory()) {\n      d('%s is not a directory', extensionsPath)\n      return []\n    }\n  } catch {\n    d('%s does not exist', extensionsPath)\n    return []\n  }\n\n  const extensionDirectories = await extensionSearch(extensionsPath)\n  const results: ExtensionPathInfo[] = []\n\n  for (const extPath of extensionDirectories.filter(Boolean)) {\n    try {\n      const manifestPath = path.join(extPath!, 'manifest.json')\n      const manifestJson = (await fs.promises.readFile(manifestPath)).toString()\n      const manifest: chrome.runtime.Manifest = JSON.parse(manifestJson)\n      const result = manifest.key\n        ? {\n            type: 'store' as const,\n            path: extPath!,\n            manifest,\n            id: generateId(manifest.key)\n          }\n        : {\n            type: 'unpacked' as const,\n            path: extPath!,\n            manifest\n          }\n      results.push(result)\n    } catch (e) {\n      console.error(e)\n    }\n  }\n\n  return results\n}\n\n/**\n * Filter any outdated extensions in the case of duplicate installations.\n */\nfunction filterOutdatedExtensions(extensions: ExtensionPathInfo[]): ExtensionPathInfo[] {\n  const uniqueExtensions: ExtensionPathInfo[] = []\n  const storeExtMap = new Map<ExtensionId, ExtensionPathInfo>()\n\n  for (const ext of extensions) {\n    if (ext.type === 'unpacked') {\n      // Unpacked extensions are always unique to their path\n      uniqueExtensions.push(ext)\n    } else if (!storeExtMap.has(ext.id)) {\n      // New store extension\n      storeExtMap.set(ext.id, ext)\n    } else {\n      // Existing store extension, compare with existing version\n      const latestExt = storeExtMap.get(ext.id)!\n      if (compareVersions(latestExt.manifest.version, ext.manifest.version) < 0) {\n        storeExtMap.set(ext.id, ext)\n      }\n    }\n  }\n\n  // Append up to date store extensions\n  storeExtMap.forEach((ext) => uniqueExtensions.push(ext))\n\n  return uniqueExtensions\n}\n\n/**\n * Load all extensions from the given directory.\n */\nexport async function loadAllExtensions(\n  session: Electron.Session,\n  extensionsPath: string,\n  options: {\n    allowUnpacked?: boolean\n  } = {}\n) {\n  const sessionExtensions = session.extensions || session\n\n  let extensions = await discoverExtensions(extensionsPath)\n  extensions = filterOutdatedExtensions(extensions)\n  d('discovered %d extension(s) in %s', extensions.length, extensionsPath)\n\n  for (const ext of extensions) {\n    try {\n      let extension: Electron.Extension | undefined\n      if (ext.type === 'store') {\n        const existingExt = sessionExtensions.getExtension(ext.id)\n        if (existingExt) {\n          d('skipping loading existing extension %s', ext.id)\n          continue\n        }\n        d('loading extension %s', `${ext.id}@${ext.manifest.version}`)\n        extension = await sessionExtensions.loadExtension(ext.path)\n      } else if (options.allowUnpacked) {\n        d('loading unpacked extension %s', ext.path)\n        extension = await sessionExtensions.loadExtension(ext.path)\n      }\n\n      if (\n        extension &&\n        extension.manifest.manifest_version === 3 &&\n        extension.manifest.background?.service_worker\n      ) {\n        const scope = `chrome-extension://${extension.id}`\n        await session.serviceWorkers.startWorkerForScope(scope).catch(() => {\n          console.error(`Failed to start worker for extension ${extension.id}`)\n        })\n      }\n    } catch (error) {\n      console.error(`Failed to load extension from ${ext.path}`)\n      console.error(error)\n    }\n  }\n}\n\nexport async function findExtensionInstall(extensionId: string, extensionsPath: string) {\n  const extensionPath = path.join(extensionsPath, extensionId)\n  let extensions = await discoverExtensions(extensionPath)\n  extensions = filterOutdatedExtensions(extensions)\n  return extensions.length > 0 ? extensions[0] : null\n}\n", "import * as fs from 'node:fs'\nimport * as path from 'node:path'\nimport debug from 'debug'\nimport { app, powerMonitor, session as electronSession } from 'electron'\n\nimport { compareVersions, fetch, getChromeVersion } from './utils'\nimport { downloadExtensionFromURL } from './installer'\nimport { WebStoreState } from './types'\n\nconst d = debug('electron-chrome-web-store:updater')\n\ninterface OmahaResponseBody {\n  response: {\n    server: string\n    protocol: string\n    daystart: {\n      elapsed_seconds: number\n      elapsed_days: number\n    }\n    app: Array<{\n      appid: string\n      cohort: string\n      status: string\n      cohortname: string\n      updatecheck: {\n        _esbAllowlist: string\n        status:\n          | 'ok'\n          | 'noupdate'\n          | 'error-internal'\n          | 'error-hash'\n          | 'error-osnotsupported'\n          | 'error-hwnotsupported'\n          | 'error-unsupportedprotocol'\n        urls?: {\n          url: Array<{\n            codebase: string\n          }>\n        }\n        manifest?: {\n          version: string\n          packages: {\n            package: Array<{\n              hash_sha256: string\n              size: number\n              name: string\n              fp: string\n              required: boolean\n            }>\n          }\n        }\n      }\n    }>\n  }\n}\n\ntype ExtensionUpdate = {\n  extension: Electron.Extension\n  id: string\n  name: string\n  version: string\n  url: string\n}\n\nconst SYSTEM_IDLE_DURATION = 1 * 60 * 60 * 1000 // 1 hour\nconst UPDATE_CHECK_INTERVAL = 5 * 60 * 60 * 1000 // 5 hours\nconst MIN_UPDATE_INTERVAL = 3 * 60 * 60 * 1000 // 3 hours\n\n/** Time of last update check */\nlet lastUpdateCheck: number | undefined\n\n/**\n * Updates are limited to certain URLs for the initial implementation.\n */\nconst ALLOWED_UPDATE_URLS = new Set(['https://clients2.google.com/service/update2/crx'])\n\nconst getSessionId = (() => {\n  let sessionId: string\n  return () => sessionId || (sessionId = crypto.randomUUID())\n})()\n\nconst getOmahaPlatform = (): string => {\n  switch (process.platform) {\n    case 'win32':\n      return 'win'\n    case 'darwin':\n      return 'mac'\n    default:\n      return process.platform\n  }\n}\n\nconst getOmahaArch = (): string => {\n  switch (process.arch) {\n    case 'ia32':\n      return 'x86'\n    case 'x64':\n      return 'x64'\n    default:\n      return process.arch\n  }\n}\n\nfunction filterWebStoreExtension(extension: Electron.Extension) {\n  const manifest = extension.manifest as chrome.runtime.Manifest\n  if (!manifest) return false\n  // TODO: implement extension.isFromStore() to check creation flags\n  return manifest.key && manifest.update_url && ALLOWED_UPDATE_URLS.has(manifest.update_url)\n}\n\nasync function fetchAvailableUpdates(extensions: Electron.Extension[]): Promise<ExtensionUpdate[]> {\n  if (extensions.length === 0) return []\n\n  const extensionIds = extensions.map((extension) => extension.id)\n  const extensionMap: Record<string, Electron.Extension> = extensions.reduce(\n    (map, ext) => ({\n      ...map,\n      [ext.id]: ext\n    }),\n    {}\n  )\n\n  const chromeVersion = getChromeVersion()\n  const url = 'https://update.googleapis.com/service/update2/json'\n\n  // Chrome's extension updater uses its Omaha Protocol.\n  // https://chromium.googlesource.com/chromium/src/+/main/docs/updater/protocol_3_1.md\n  const body = {\n    request: {\n      '@updater': 'electron-chrome-web-store',\n      acceptformat: 'crx3',\n      app: [\n        ...extensions.map((extension) => ({\n          appid: extension.id,\n          updatecheck: {}\n          // API always reports 'noupdate' when version is set :thinking:\n          // version: extension.version,\n        }))\n      ],\n      os: {\n        platform: getOmahaPlatform(),\n        arch: getOmahaArch()\n      },\n      prodversion: chromeVersion,\n      protocol: '3.1',\n      requestid: crypto.randomUUID(),\n      sessionid: getSessionId(),\n      testsource: process.env.NODE_ENV === 'production' ? '' : 'electron_dev'\n    }\n  }\n\n  const response = await fetch(url, {\n    method: 'POST',\n    headers: {\n      'content-type': 'application/json',\n      'X-Goog-Update-Interactivity': 'bg',\n      'X-Goog-Update-AppId': extensionIds.join(','),\n      'X-Goog-Update-Updater': `chromiumcrx-${chromeVersion}`\n    },\n    body: JSON.stringify(body)\n  })\n\n  if (!response.ok) {\n    d('update response not ok')\n    return []\n  }\n\n  // Skip safe JSON prefix\n  const text = await response.text()\n  const prefix = `)]}'\\n`\n  if (!text.startsWith(prefix)) {\n    d('unexpected update response: %s', text)\n    return []\n  }\n\n  const json = text.substring(prefix.length)\n  const result: OmahaResponseBody = JSON.parse(json)\n\n  let updates: ExtensionUpdate[]\n  try {\n    const apps = result?.response?.app || []\n    updates = apps\n      // Find extensions with update\n      .filter((app) => app.updatecheck.status === 'ok')\n      // Collect info\n      .map((app) => {\n        const extensionId = app.appid\n        const extension = extensionMap[extensionId]\n        const manifest = app.updatecheck.manifest!\n        const pkg = manifest!.packages.package[0]\n        return {\n          extension,\n          id: extensionId,\n          version: manifest.version,\n          name: pkg.name,\n          url: app.updatecheck.urls!.url[0].codebase\n        }\n      })\n      // Remove extensions without newer version\n      .filter((update) => {\n        const extension = extensionMap[update.id]\n        return compareVersions(extension.version, update.version) < 0\n      })\n  } catch (error) {\n    console.error('Unable to read extension updates response', error)\n    return []\n  }\n\n  return updates\n}\n\nasync function updateExtension(session: Electron.Session, update: ExtensionUpdate) {\n  const sessionExtensions = session.extensions || session\n  const extensionId = update.id\n  const oldExtension = update.extension\n  d('updating %s %s -> %s', extensionId, oldExtension.version, update.version)\n\n  // Updates must be installed in adjacent directories. Ensure the old install\n  // was contained in a versioned directory structure.\n  const oldVersionDirectoryName = path.basename(oldExtension.path)\n  if (!oldVersionDirectoryName.startsWith(oldExtension.version)) {\n    console.error(\n      `updateExtension: extension ${extensionId} must conform to versioned directory names`,\n      {\n        oldPath: oldExtension.path\n      }\n    )\n    d('skipping %s update due to invalid install path %s', extensionId, oldExtension.path)\n    return\n  }\n\n  // Download update\n  const extensionsPath = path.join(oldExtension.path, '..', '..')\n  const updatePath = await downloadExtensionFromURL(update.url, extensionsPath, extensionId)\n  d('downloaded update %s@%s', extensionId, update.version)\n\n  // Reload extension if already loaded\n  if (sessionExtensions.getExtension(extensionId)) {\n    sessionExtensions.removeExtension(extensionId)\n    await sessionExtensions.loadExtension(updatePath)\n    d('loaded update %s@%s', extensionId, update.version)\n  }\n\n  // Remove old version\n  await fs.promises.rm(oldExtension.path, { recursive: true, force: true })\n}\n\nasync function checkForUpdates(session: Electron.Session) {\n  // Only check for extensions from the store\n  const sessionExtensions = session.extensions || session\n  const extensions = sessionExtensions.getAllExtensions().filter(filterWebStoreExtension)\n  d('checking for updates: %s', extensions.map((ext) => `${ext.id}@${ext.version}`).join(','))\n\n  const updates = await fetchAvailableUpdates(extensions)\n  if (!updates || updates.length === 0) {\n    d('no updates found')\n    return []\n  }\n\n  return updates\n}\n\nasync function installUpdates(session: Electron.Session, updates: ExtensionUpdate[]) {\n  d('updating %d extension(s)', updates.length)\n  for (const update of updates) {\n    try {\n      await updateExtension(session, update)\n    } catch (error) {\n      console.error(`checkForUpdates: Error updating extension ${update.id}`)\n      console.error(error)\n    }\n  }\n}\n\n/**\n * Check session's loaded extensions for updates and install any if available.\n */\nexport async function updateExtensions(\n  session: Electron.Session = electronSession.defaultSession\n): Promise<void> {\n  const updates = await checkForUpdates(session)\n  if (updates.length > 0) {\n    await installUpdates(session, updates)\n  }\n}\n\nasync function maybeCheckForUpdates(session: Electron.Session) {\n  const idleState = powerMonitor.getSystemIdleState(SYSTEM_IDLE_DURATION)\n  if (idleState !== 'active') {\n    d('skipping update check while system is in \"%s\" idle state', idleState)\n    return\n  }\n\n  // Determine if enough time has passed to check updates\n  if (lastUpdateCheck && Date.now() - lastUpdateCheck < MIN_UPDATE_INTERVAL) {\n    return\n  }\n  lastUpdateCheck = Date.now()\n\n  void updateExtensions(session)\n}\n\nexport async function initUpdater(state: WebStoreState) {\n  const check = () => maybeCheckForUpdates(state.session)\n\n  switch (process.platform) {\n    case 'darwin':\n      app.on('did-become-active', check)\n      break\n    case 'win32':\n    case 'linux':\n      app.on('browser-window-focus', check)\n      break\n  }\n\n  const updateIntervalId = setInterval(check, UPDATE_CHECK_INTERVAL)\n  check()\n\n  app.on('before-quit', (event) => {\n    queueMicrotask(() => {\n      if (!event.defaultPrevented) {\n        d('stopping update checks')\n        clearInterval(updateIntervalId)\n      }\n    })\n  })\n}\n"],
  "mappings": "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",
  "names": ["import_electron", "path", "import_debug", "import_electron", "fs", "path", "import_electron", "import_debug", "path", "debug", "d", "debug", "AdmZip", "electronSession", "d", "debug", "handle", "fs", "path", "import_debug", "import_electron", "d", "debug", "app", "electronSession", "electronSession"]
}
